# -*- coding: utf-8 -*-
"""ancilla-free-revised.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MGZQ3Yd3MUmJCuyJcJqPp39VVeixKy3u
"""

import numpy as np
import math
import itertools
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1.inset_locator import zoomed_inset_axes
from mpl_toolkits.axes_grid1.inset_locator import mark_inset

# Qutrit Description
L = np.matrix([[0,1,1],[0,0,1],[0,0,0]])
H = np.matrix([[1,0,0],[0,-1,-1],[0,-1,-1]])

lambda_0 = 0.5
lambda_2 = 0.5
lambda_1 = 1

# Eigenvectors of Probe Space
eigen_0 = np.matrix([[1],[0],[0]]) #corresponds to rho_0
eigen_1 = np.matrix([[0],[1],[0]]) #corresponds to rho_0
eigen_2 = np.matrix([[0],[0],[1]]) #corresponds to rho_1

eigenstates = [eigen_0, eigen_1, eigen_2]


# Writes number n in basis b using length digits
# Helper function borrowed from https://stackoverflow.com/questions/2267362/how-to-convert-an-integer-to-a-string-in-any-base

def numberToBase(n, b, length):
    if n == 0:
        return "0"*length
    digits = []
    while n:
        digits.append(str(int(n % b)))
        n //= b

    number = digits[::-1]
    extra_zeros = ["0" for i in range(length- len(digits))]
    final_number = extra_zeros + number

    return ''.join(final_number)


def conj(matrix):
    return np.conjugate(matrix.T)


# Generates all the possible codewords according to our eigenvalue approximation construction
def generate_code_states(m):
    m_0 = math.floor(m*lambda_0)
    m_1 = m
    m_2 = m - m_0


    rho_1_elements = ["1" for i in range(m_1)]
    final_permutations_1 = [''.join(rho_1_elements)]


    combinations_0 = itertools.combinations(list(range(m)), m_2)
    reduced_permutations_0 = []

    for p in combinations_0:
        new_p = ['0' for i in range(m)]

        for index in p:
            new_p[index] = '2'

        reduced_permutations_0.append(new_p)


    final_permutations_0 = [''.join(word) for word in reduced_permutations_0]


    return final_permutations_0, final_permutations_1

# Finds all states that differ at exactly two points (i.e., by a transposition)
# Returns a dictionary with the neighbors of each state
def find_neighbors(permutations):
    graph = {}
    for p in permutations:
        graph[p] = []

    for i in range(len(permutations)):
        p = permutations[i]

        for q in permutations[i:]:
            count = 0

            p_list = list(p)
            q_list = list(q)

            for i in range(len(p_list)):
                if p_list[i] != q_list[i]:
                    count += 1


            if count == 2:
                graph[p].append(q)
                graph[q].append(p)


    return graph



# Takes neighbor from find_neighbors and finds a (relatively optimal) coloring
def find_coloring(graph):
    nodes = graph.keys()

    colors = {}

    for node in nodes:
        colors[node] = -1

    for node in nodes:
        neighbors = graph[node]

        if len(neighbors) > 0:
            color = 0

            neighbor_colors = [colors[n] for n in neighbors]
            max_color = max(neighbor_colors)

            if max_color == -1:
                color = 0
            else:
                for i in range(max_color+2):
                    if i not in neighbor_colors:
                        color = i
                        break

            colors[node] = color

        else:
            colors[node] = 0



    return colors


# Translates the colors from the coloring function to states in base 3
def colors_to_states(graph, max_color):
    length = len(numberToBase(max_color, 3, 1))
    new_graph = {}

    for key in graph.keys():
        new_graph[key] = numberToBase(graph[key], 3, length)

    return new_graph

# Takes a state in list form and produces corresponding vector
def list_to_state(state_list):
    if len(state_list) == 0:
        return 1
    else:
        return np.kron(eigenstates[state_list[0]], list_to_state(state_list[1:]))


# Converts logical states from ket notation to vectors and adds them up for small code
def logical_state(states_graph):
    state =0

    for key in states_graph.keys():
        value = states_graph[key]
        state_list = list(key + value)
        state_list = [int(i) for i in state_list]

        state += list_to_state(state_list)

    return state



# This is a helper function that checks whether
# the phases of the random code satisfy our condition
def check_phase_condition(permutations, phases, threshold):
    normalization = len(permutations)
    positions = len(permutations[0])

    all_neighbors = find_neighbors(permutations)
    delta_dictionary = [[[0 for y in range(positions)] for x in range(positions)], [[0 for y in range(positions)] for x in range(positions)]]


    # We set this up so that [0][x][y]
    # corresponds to the x,y entires of the permutations being different
    # with the primary string having values 0,2 respectively
    # and the entry [1][x][y] corresponds to
    # x,y entries different with the primary string having values 2,0 respectively


    # We also always assume x to be the smallest index for uniqueness

    for perm in permutations:
        for neighbor in all_neighbors[perm]:
            different_indices = [i for i in range(len(perm)) if perm[i] != neighbor[i]]

            x = min(different_indices)
            y = max(different_indices)

            if int(perm[x]) == 0:
                delta_dictionary[0][x][y] += (1/normalization)*np.e**(-1j*phases[perm] + 1j*phases[neighbor])

            else:
                delta_dictionary[1][x][y] += (1/normalization)*np.e**(-1j*phases[perm] + 1j*phases[neighbor])


    all_deltas = []
    for x in range(positions):
        for y in range(positions):
            all_deltas.append(np.abs(delta_dictionary[0][x][y]))
            all_deltas.append(np.abs(delta_dictionary[1][x][y]))

    M = max(all_deltas)
    if M < threshold:
        return True
    else:
        return False



# logical state generation for random code
# the coefficient refers to the threshold we use to accept or reject a set of phases
def ancilla_free_logical_states_helper(permutations, coefficient=2):
    state = 0
    phases = {}

    for perm in permutations:
        state_list = list(perm)
        state_list = [int(i) for i in state_list]

        phase = np.random.uniform(0, np.pi)
        phases[perm] = phase

        state += (np.e**(phase*1j))*list_to_state(state_list)


    sufficient = check_phase_condition(permutations, phases, coefficient/(len(permutations[0])))


    return state, sufficient



# Combines all the helper functions above to generate the logical states for both codes
# Mode "small" corresonds to small-ancilla
# Mode "random" corresponds to the ancilla-free (random phase) code

def generate_logical_states(m, mode='small'):
    perm_0, perm_1 = generate_code_states(m)

    norm_0 = 1/np.sqrt(len(perm_0))
    norm_1 = 1/np.sqrt(len(perm_1))


    if mode == 'small':

        graph_0 = find_neighbors(perm_0)
        graph_1 = find_neighbors(perm_1)

        coloring_0 = find_coloring(graph_0)
        coloring_1 = find_coloring(graph_1)

        max_color_0 = max(coloring_0.values())
        max_color_1 = max(coloring_1.values())
        max_color = max(max_color_0, max_color_1)

        final_states_dict_0 = colors_to_states(coloring_0, max_color)
        final_states_dict_1 = colors_to_states(coloring_1, max_color)


        logical_0 = norm_0*logical_state(final_states_dict_0)
        logical_1 = norm_1*logical_state(final_states_dict_1)

        total_qubits = round(math.log(len(logical_0),3))

        return logical_0, logical_1, total_qubits

    elif mode=='random':
        logical_1,_ = ancilla_free_logical_states_helper(perm_1)
        logical_1 = norm_1*logical_1

        c = -0.275*m + 2.775

        logical_0, sufficient = ancilla_free_logical_states_helper(perm_0, coefficient = c)

        while not sufficient:
            logical_0, sufficient = ancilla_free_logical_states_helper(perm_0, coefficient=c)

        logical_0 = norm_0*logical_0

        return logical_0, logical_1, m

    else:
        print("Invalid Mode")

# Generates a Lindblad operator acting on the lth probe, tensored with identity operators acting on the rest of the system
def multi_state_lindblad(L, l, m):
    result = 1

    for i in range(l):
        result = np.kron(result, np.identity(3))

    result = np.kron(result, L)

    for i in range(m-l-1):
        result = np.kron(result, np.identity(3))

    return result

# mutli-qubit Hamiltonian
# Every probe evolves under the same Hamiltonian H
def multi_qubit_hamiltonian(Hamiltonian, m, total_qubits):
    result = 0

    for i in range(m):
        result += multi_state_lindblad(Hamiltonian, i, total_qubits)

    return result

# Calculates gamma for both codes
# Mode "small" corresonds to small-ancilla
# Mode "random" corresponds to the ancilla-free (random phase) code
def gamma(m, mode="small"):

    # Approximation
    m_0 = math.floor(m*lambda_0)
    m_1 = m
    m_2 = m - m_0


    # Parameters
    b_0 =np.trace((m_0/m - lambda_0)*eigen_0*conj(eigen_0)*L + (m_2/m - lambda_2)*eigen_2*conj(eigen_2)*L)
    b_1 = np.trace((m_1/m - lambda_1)*eigen_1*conj(eigen_1)*L )


    a_0 =np.trace((m_0/m - lambda_0)*eigen_0*conj(eigen_0)*conj(L)*L + (m_2/m - lambda_2)*eigen_2*conj(eigen_2)*conj(L)*L)
    a_1=np.trace((m_1/m - lambda_1)*eigen_1*conj(eigen_1)*conj(L)*L)


    logical_0, logical_1, total_qubits = generate_logical_states(m, mode)


    mu =np.trace(lambda_0*eigen_0*conj(eigen_0)*conj(L)*L + lambda_2*eigen_2*conj(eigen_2)*conj(L)*L)
    B = 0


    for i in range(m):
        lindblad = multi_state_lindblad(L, i, total_qubits)


        b_0_multi_state = b_0*np.identity(3**total_qubits)
        b_1_multi_state = conj(b_1*np.identity(3**total_qubits))


        B += (lindblad- b_0_multi_state)*logical_0*conj(logical_1)*(conj(lindblad)-b_1_multi_state)

    # calculate gamma
    trace_B = np.sum(np.linalg.svd(B)[1])
    gamma = m*(mu - b_0*b_1+0.5*(a_0 + a_1))- trace_B

    # calculate the trace parameter for the QFI time evolution
    rho_0 = logical_0*conj(logical_0)
    rho_1 = logical_1*conj(logical_1)

    multi_H = multi_qubit_hamiltonian(H,m, total_qubits)



    return gamma


# ms- list of m's for which gamma is computed
# 'small'/ 'random' mode for the two codes respectively
# calculated gamma for a list of m's for either the small-ancilla or random code
def main_sequence(ms, mode='small'):

    gammas = []
    reps = 50

    for m in ms:
        if mode=='small':
            g_optimal = gamma(m, mode)
        elif mode=='random':

            g_optimal = min([gamma(m,mode) for i in range(reps)])

        gammas.append(g_optimal)

        print("Calculated gamma for " + str(m) + '. Gamma= ' + str(g_optimal) +  ' (' + mode + ' code)')

    plt.plot(ms, gammas)
    plt.show()



# Plots gamma_L vs m
# ChatGPT was used to assist writing some of the plotting functions
def plot_data(ms_small, ms_random, gamma_small, gamma_random):

    colors = ['#0077B6', '#F18D9E']

    # Create a plot
    plt.figure(figsize=(8, 6))
    plt.plot(ms_small, gamma_small, label="$\gamma$, small-ancilla code", marker='o', linestyle='--', color=colors[0], linewidth=2)
    plt.plot(ms_random, gamma_random, label="$\gamma$, random code", marker='s', linestyle='--', color=colors[1], linewidth=2)

    # Add labels and a legend
    plt.xlabel("number of probes $m$", fontsize=14)
    plt.ylabel("$\gamma_L$", fontsize=14)
    plt.title("$\gamma_L$ vs. number of probes($m$)", fontsize=16)
    plt.legend(fontsize=12, loc='best')

    # Customize the grid
    plt.grid(True, linestyle='--', alpha=0.6)

    # ticks
    plt.xticks([3,4,5,6,7])

    # Show the plot
    plt.tight_layout()
    plt.savefig("gamma_plot.pdf")
    plt.show()




nature_colors = {
    "blue": "#007acc",
    "red": "#c60000",
    "green": "#7fbf3f",
    "purple": "#68217a",
    "orange": "#ff6f00",
    "pink": "#ff64b7",
    'yellow': '#ffd300',
    'light blue': '#9ac9eb',
    "lilac": "#b17acc"
}


# Returns the values of the fisher information over a time interval
# for given m and gamma
def fisher_information_value(m, gamma, interval):
    m_0 = math.floor(m*lambda_0)
    m_1 = m
    m_2 = m - m_0

    # These are defined in the paper
    # Equatiosn E1, E2
    rho_0_tilde = (m_0/m)*eigen_0*conj(eigen_0) + (m_2/m)*eigen_2*conj(eigen_2)
    rho_1_tilde = eigen_1*conj(eigen_1)

    trace_coefficient = np.trace((rho_0_tilde- rho_1_tilde)*H)
    QFI = np.array([(trace_coefficient**2)*(t**2)*np.exp(-2*gamma*t) for t in interval])
    return QFI


# Plots the above function
# def plot_fisher_information(ms, gammas, interval, label_prefices, colors, style):
#     for m,g,color, label_prefix in zip(ms, gammas, colors, label_prefices):
#         qfis= fisher_information_value(m,g, interval)
#         plt.plot(interval, qfis, label=label_prefix, color=color, linestyle=style)


# Modified to allow ax as an input parameter
def plot_fisher_information(ax, ms, gammas, interval, label_prefices, colors, style):
    for m,g,color, label_prefix in zip(ms, gammas, colors, label_prefices):
        qfis= fisher_information_value(m,g, interval)
        ax.plot(interval, qfis, label=label_prefix, color=color, linestyle=style)


def plot_all_fisher_information(ms_small, ms_random, gamma_small, gamma_random):
    fig, ax = plt.subplots(figsize=(10, 6))
    interval = np.linspace(0, 100, 1000)  # Adjust the number of points as needed
    # axins = zoomed_inset_axes(fig, 6, loc=1)

    ideal = [t**2 for t in interval]

    labels_random = ['random m=' + str(m) for m in ms_random]
    labels_small = ['small m=3', 'small m=5','small m=4,6', 'small m=7' ]

    nature_colors_list_random = [nature_colors['blue'],nature_colors['orange'] , nature_colors['green'], nature_colors['yellow'], nature_colors['purple']]
    nature_colors_list_small = [nature_colors['blue'],  nature_colors['green'],nature_colors['yellow'], nature_colors['purple']]


    # Plot small and random data together with Nature colors
    plot_fisher_information(ax,ms_small, gamma_small, interval, label_prefices=labels_small, colors=nature_colors_list_small, style='solid')
    plot_fisher_information(ax,ms_random, gamma_random, interval, label_prefices=labels_random, colors=nature_colors_list_random, style='dashed')

    ax.plot(interval, ideal, label='Optimal QFI', color = 'black', linestyle='dotted')

    plt.xlabel('Time (t)')
    plt.ylabel('$QFI/m^2$')

    ### Region of main plot
    plt.xlim(0, 100)
    plt.ylim(0, 500)
    plt.title('Quantum Fisher Information vs. Time')


    # Inserted subplot
    ### Zoom-in rate
    axins = zoomed_inset_axes(ax, 14, loc=1)
    plot_fisher_information(axins,ms_small, gamma_small, interval, label_prefices=labels_small, colors=nature_colors_list_small, style='solid')
    plot_fisher_information(axins,ms_random, gamma_random, interval, label_prefices=labels_random, colors=nature_colors_list_random, style='dashed')
    axins.plot(interval, ideal, label='Optimal QFI', color = 'black', linestyle='dotted')
    axins.grid(False)
    ### Region of inserted subplot
    axins.set_xlim(0, 4)
    axins.set_ylim(0, 8)
    ### Ticks
    axins.set_xticks([0,1,2,3,4])
    axins.set_yticks([0,4,8])

    mark_inset(ax, axins, loc1=2, loc2=4, fc="none", ec="0.8")



    ax.legend(loc = 2)
    # ax.grid()
    # plt.grid()
    plt.savefig("qfi_plot.pdf")

    plt.show()

def main_fisher_graph():
    # Plots all the fisher information data we gathered as a function of time
    ms_small = [3,5,6,7]
    ms_random = range(3,8)

    gamma_small = [0.035898384862239396, -2.042810365310288e-14, 0.022774424948114103, -6.483702463810914e-13, 0.016685226450028345]
    # We just want to plot one of the gamma=0 functions
    gamma_small.remove(-2.042810365310288e-14)


    gamma_random = [0.08578643762690064, 0.05258347522582785, 0.036667238669362945, 0.030047655007136242, 0.03647342393988229  ]

    #Use this data set- I had forgotten to conjugate things when I calculated the first one
    gamma_random_2 = [0.08578643762690152, 0.05415379690432287, 0.025752844121693208, 0.023800068886585812,0.03449453703027139 ]

    #plot_data(ms_small, ms_random, gamma_small, gamma_random)
    plot_all_fisher_information(ms_small, ms_random, gamma_small, gamma_random_2)

# main_sequence([4], 'random')
main_fisher_graph()

gamma_small = [0.035898384862239396, -2.042810365310288e-14, 0.022774424948114103, -6.483702463810914e-13, 0.016685226450028345]
gamma_random = [0.08578643762690064, 0.05258347522582785, 0.036667238669362945, 0.030047655007136242, 0.03647342393988229  ]
gamma_random_2 = [0.08578643762690152, 0.05415379690432287, 0.025752844121693208, 0.023800068886585812,0.03449453703027139 ]
plot_data(range(3,8), range(3,8), gamma_small, gamma_random_2)